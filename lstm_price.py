# -*- coding: utf-8 -*-
"""LSTM-Price.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PzALYQFzYVy9bqef9D7NJm05k83nsu0q
"""

#資料匯入
import pandas as pd
import numpy as np
from google.colab import files
uploaded = files.upload()

import io
df = pd.read_csv(io.StringIO(uploaded['ABS_data_0531.csv'].decode('utf-8')))
df = df.dropna(how='all').iloc[:,0:4]

df

#控制不同原物料
training_set = df.iloc[:,3:4].values

#做標準化
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler(feature_range = (0, 1))
training_set_scaled = sc.fit_transform(training_set)

training_set_scaled.shape

train_period = 10
train_period_end = 95

X_train = []   #預測點的前 period 天的資料
y_train = []   #預測點
for i in range(train_period, train_period_end):  #從第30期開始training
    X_train.append(training_set_scaled[i - train_period:i, 0])
    y_train.append(training_set_scaled[i, 0])
X_train, y_train = np.array(X_train), np.array(y_train)  # 轉成numpy array的格式，以利輸入 RNN

#原本的data每一個都有很多個元素, 現在讓每個元素拆成1, 就是多加一個維度即可
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

# Import the Keras libraries and packages
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout

model = Sequential()

#return_sequence為是否ouput整個序列的值
#Units 為「一個cell之中, hidden之中neuron的個數, 所以還是在一個LSTM Cell之中」
#input_shape is (2,10) which means the number of time steps is 2 and the number of input units is 10
model.add(LSTM(units = 50, return_sequences = True, input_shape = (X_train.shape[1], 1)))
model.add(Dropout(0.2))

# hidden layer
#預設的activation function為tanh
model.add(LSTM(units = 30, return_sequences = True))
model.add(Dropout(0.2))
model.add(LSTM(units = 50, return_sequences = True))
model.add(Dropout(0.2))

#即將於ouput layer做連接, 因此return_sequence為false, 只輸出一個值
model.add(LSTM(units = 50, return_sequences = False))
model.add(Dropout(0.2))

#output layer
model.add(Dense(units = 1))

model.compile(optimizer = 'adam', loss = 'mean_squared_error')

# 進行訓練
model.fit(X_train, y_train, batch_size = 10, epochs = 30)

predict_lis = [] #用來儲存最後predict出來的結果

#Raw data(從要predict的前30期開始算, 並且沒有被scale)
start_date = train_period_end - train_period #testing開始的日期, 為要predict的第一天的前training天
rawdata = training_set[start_date: train_period_end]  #這邊只是沒改training set的名字

def predict_process(loc_num): #假設輸入的東西從0~29
  global predict_lis
  global rawdata
  temp_train = rawdata[loc_num : loc_num + train_period] #資料切成train_period的大小
  temp_train = sc.fit_transform(temp_train)
  temp_train = np.reshape(temp_train, (1, train_period, 1)) 
  
  predicted_stock_price = model.predict(temp_train) #model predict
  predicted_stock_price = sc.inverse_transform(predicted_stock_price) 
  
  predict_lis.append(predicted_stock_price[0][0]) #把資料弄到預測集
  rawdata = np.append(rawdata, [[predicted_stock_price[0][0]]], axis = 0)

for i in range(30):
  predict_process(i)

data_output = pd.DataFrame(columns= ['SM'], data=predict_lis)
data_output.to_csv('try3.csv')

files.download('try3.csv')

import matplotlib.pyplot as plt  # for 畫圖用

real_price = training_set[91:120]

plt.plot(predict_lis, color = 'blue', label = 'Predicted Material Price')  # 藍線表示預測股價
plt.plot(real_price, color = 'red', label = 'Real Material Price')
plt.title('Price Prediction')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

